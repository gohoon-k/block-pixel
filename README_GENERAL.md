# Pixel - version control with Minecraft
마인크래프트의 지형, 건축물, (플레이어를 제외한)엔티티 정보를 쉽게 버전관리하기 위한, 서버측 spigot 플러그인.  
  
백업 지점 만들기, 백업 지점으로 이동 및 새로운 평행세계 생성, 평행세계간 병합, 백업지점으로의 복원 등의 기능이 있습니다.  
  
<b>이 플러그인은 월드의 플레이어 데이터, 도전과제, 통계, 월드 정보(gamerule 등) 데이터는 버전관리하지 않습니다.</b>
  
![미리보기](pixel_preview.png)

## 이 파일의 내용
[서버에 추가](#서버에-추가)  
[사용 가능한 커맨드](#사용-가능한-커맨드)  
[작동](#작동)  
&nbsp;&nbsp;&nbsp;&nbsp;[백업지점과 평행세계, 그리고 시간여행](#백업지점과-평행세계-그리고-시간여행)  
&nbsp;&nbsp;&nbsp;&nbsp;[HEAD](#HEAD)  
&nbsp;&nbsp;&nbsp;&nbsp;[평행세계 합치기](#평행세계-합치기)  
&nbsp;&nbsp;&nbsp;&nbsp;[백업지점 확인 인수](#백업지점-확인-인수)  
[생길법한 궁금증](#생길법한-궁금증)  
&nbsp;&nbsp;&nbsp;&nbsp;[용량 안터져요?](#용량-안터져요)  
&nbsp;&nbsp;&nbsp;&nbsp;[속도는 어때요?](#속도는-어때요)  

## 서버에 추가
플러그인 jar 파일을 서버의 `/plugins` 디렉터리에 배치합니다.  
Nether 및 TheEnd 는 그 자체로 버전관리가 수행되고, Overworld 는 버전관리를 위한 월드 <i><b>level_name</b></i>_overworld 를 첫 서버 실행시 생성합니다.  
그 생성된 월드는 생성 시점의 <i><b>level_name</b></i> 월드의 복제입니다.  
  
서버가 정상적으로 실행되고 나면, 초기화를 위해 다음 사항을 수행합니다.  

서버의 콘솔에서  
`pixel allow 당신의_플레이어_이름`

마인크래프트 클라이언트에서  
`/pixel init`  
`/pixel commit all "Initial Commit"`

처음 초기화하는 과정은 어느정도 시간이 걸리므로 충분한 여유를 갖고 진행해주세요.

작업이 완료되고 'successfully committed ~~' 메시지가 뜬다면, 모두 끝났습니다!  
이제 여러분은 아래의 커맨드들을 이용하여 월드의 일부 데이터를 버전관리할 수 있게 되었습니다.

이후에 당신이 아닌 다른 사용자에게 `/pixel` 커맨드를 사용하도록 허용하려면, 서버 콘솔에서 `pixel allow` 커맨드를 사용합니다.

## 사용 가능한 커맨드
- ```pixel allow <player_name>```  
  <b>서버 콘솔에서만 사용 가능</b>  
  특정 사용자가 아래의 나머지 `/pixel` 커맨드를 사용할 수 있도록 허용합니다.


- ```pixel deny <player_name>```  
  <b>서버 콘솔에서만 사용 가능</b>  
  특정 사용자가 아래의 나머지 `/pixel` 커맨드를 사용할 수 없도록 권한을 취소합니다.


- ```/pixel init [force]```  
  플러그인과 버전관리 데이터를 초기화합니다.  
  `force` 옵션이 지정되고 이미 버전관리중인 데이터가 있을 경우 그 기록이 삭제되고, 현재의 실제 월드에 반영되어있는 데이터가 초기 데이터로 설정됩니다.


- ```/pixel commit <dimension> <commit_message>```  
  현재 월드의 상태로 백업지점 하나를 만듭니다.
    - dimension : 변경사항을 백업지점에 포함할 월드
    - commit_message : 백업사항 각각을 구별하기 위한 메시지. 띄어쓰기를 해도 된다.


- ```/pixel reset <dimension> <steps|commit_hash>```  
  특정 백업지점으로 시간을 되돌리거나 현재 백업지점으로부터 뒤로 n 개 뒤의 백업지점의 상태로 시간을 되돌립니다.
    - dimension : 리셋을 반영할 월드
    - steps : 뒤로 몇 커밋을 이동할지에 대한 값
    - commit_hash : 이동할 백업지점의 유일한 ID. 이동한 커밋의 이후 커밋은 모두 삭제됩니다.


- ```/pixel discard <dimension>```  
  따로 백업지점을 만들지 않은 모든 변경사항을 취소하고 마지막 백업지점(혹은 HEAD[[1]](#HEAD)가 가리키는 현재 백업지점) 상태로 되돌립니다.
    - dimension : 변경사항을 취소할 월드


- ```/pixel branch <new_branch_name|-d> [branch_to_delete]```  
  현재의 백업지점을 기준으로하는 새로운 평행세계를 생성하거나, 현재 속한 평행세계가 아닌 다른 평행세계(와 그에 포함된 모든 백업지점) 하나를 제거합니다.
    - new_branch_name : 생성할 평행세계의 이름
    - -d : 평행세계를 삭제하려는 경우 해당 값을 인수에 전달
    - branch_to_delete : 첫 인수가 `-d` 일 경우 반드시 전달해야함. 삭제할 퍙행세계의 이름.


- ```/pixel checkout <dimension> <branch|commit_hash> <commit_confirm>```  
  특정 평행세계, 혹은 백업지점으로 시간여행합니다.
    - dimension : 평행세계, 혹은 백업지점의 상황을 반영할 월드
    - branch : 이동할 타겟 평행세계
    - commit_hash : 이동할 타겟 백업지점
    - commit_confirm : 체크아웃 하기 전에 현재까지의 변경사항에 대한 백업지점을 만들었는지에 대한 확인<sup>[[2]](#백업지점-확인-인수)</sup>


- ```/pixel checkout <dimension> -recover```  
  버전관리 데이터가 꼬였을 것으로 예상되는 경우, 마지막 백업지점의 상태로 버전관리 데이터를 clean 할 수 있습니다.


- ```/pixel merge <dimension> <branch|commit_hash> <merge_mode> <commit_confirm>```  
  특정 백업지점 혹은 평행세계를 HEAD가 가리키는 시점과 병합<sup>[[3]](#평행세계-합치기)</sup>합니다.
    - dimension : 병합을 진행할 월드
    - branch : 병합을 진행할 source 평행세계. (A를 B에 병합한다고 할 때 A를 말함)
    - commit_hash : 병합을 진행할 source 백업지점. (A를 B에 병합한다고 할 때 A를 말함)
    - merge_mode : keep 혹은 replace 중 하나. keep 일 경우 병합 충돌 발생 시 HEAD 의 값을, replace 일 경우 source 의 값을 반영합니다.
    - commit_confirm : 병합을 진행하기 전에 현재까지의 변경사항에 대한 백업지점을 대한 확인<sup>[[2]](#백업지점-확인-인수)</sup>


- ```/pixel merge abort```  
  병합을 중단합니다. <b>병합이 현재 진행중일 때만 수행 가능합니다.</b>


- ```/pixel list <what>```  
  백업지점, 혹은 평행세계의 목록을 출력합니다.
    - what : commits 혹은 branches 중 하나. 각각 백업지점의 목록과 평행세계의 목록을 출력합니다.


- ```/pixel tp <target> <dimension>```  
  플레이어를 지정한 월드의 동일한 좌표 위치로 텔레포트합니다.
    - target : 텔레포트할 플레이어의 닉네임
    - dimension : 도착 월드. dummy(기존의 Overworld(<b><i>level_name</i></b> 월드)) 혹은 overworld(버전관리가 진행되는 Overworld(<b><i>level_name</i>_overworld</b> 월드)) 중 하나.


- ```/pixel whereis <target>```  
  플레이어가 현재 어느 월드에 있는지를 출력합니다.
    - target : 확인할 플레이어의 닉네임

## 작동
이 플러그인은 사용자가 `/pixel init`을 수행한 이후에 생성한 모든 백업지점을 플러그인 디렉터리에 저장하여 관리합니다.  
클라이언트가 읽는 월드 디렉터리의 내용을 직접 버전관리하는 것이 아니기 때문에, 버전관리 데이터와 실제 맵 사이에는 항상 차이가 있습니다.  
단지, 사용자가 특정 명령어를 수행하면 클라이언트 월드 디렉터리의 내용을 버전관리 디렉터리로 복사할 뿐입니다.  
  
또, 해당 플러그인을 설치한 채로 서버에 접속하면 무조건 버전관리가 진행되는 월드(_overworld, _nether, _the_end 중 하나)로 스폰됩니다.
따라서 기존의 overworld 로 이동할 일이 있다면 `/pixel tp` 커맨드를 사용해주세요.

### 백업지점과 평행세계, 그리고 시간여행
**백업지점(commit)은 말 그대로 상태를 기록하고싶은 시점**입니다.  
예를 들어 커다란 건축물 하나를 만들었다고 하죠. 이 시점은 백업을 해두고 나중에 돌아올 일이 있으면 서버를 끄거나 할 거 없이 편리하게 돌아오고싶어! 같은 생각이 들겠죠? 그럴 때 만드는게 백업지점입니다.  
여기서 '돌아온다'의 의미는, 이후에 만든 모든 변경사항을 삭제하고 돌아오는 의미와, 이후에 만든 변경사항을 그대로 두고 잠시 돌아오는 의미 모두 가능합니다.  
전자는 **아예 시간을 돌려버리는거고(reset)**, 후자는 **잠시 시간여행을 한다고(checkout)** 볼 수 있겠죠(물론 플레이어와 그 데이터는 버전관리되지 않으므로 모든 플레이어가 함께하는 시간여행이 되겠지만요).  
  
**평행세계(branch)는 특정 시점(백업지점)으로부터 갈라진 서로 다른 세계**를 말합니다.  
예를 들어, 특정 시점에서 백업지점 A를 만들었습니다. 그러고 나서 계속 무언가의 변경사항을 만들었고, 그러고 나서 다시 백업지점 B를 만들었어요.  
근데, 언급한 특정 시점 이후에 만든것과 다른 무언가를 같은 위치에 만들어보고 싶어요. 이거 말고 다른걸 만들었으면 어떨까? 싶은거죠. 그렇다고 다 부수고 다시 만들었다간, 다시 만든게 마음에 안들면 망해요. 그럴 때 만드는게 평행세계입니다.  
언급한 '특정 시점'에서 갈라져 나온 평행세계 하나를 만들면, A 백업지점의 상태에서 다른 무언가를 만들어 백업지점 C를 다시 만들 수 있고, 그 상황에서도 B는 아무런 문제 없이 남아있을 수 있습니다.  
이 때 B와 C는 A에서 갈라져나온 평행세계들인거죠.  
  
또, **백업지점과 평행세계에는 고유한 이름이 있습니다**. 백업지점의 이름은 백업지점을 만들 때 사용자의 입력과 무관하게 자동으로 생성되고, 평행세계의 이름은 직접 지정할 수 있습니다.  
그리고, 플러그인을 초기화할 때 백업지점을 하나 만들었는데 이는 'master'라는 이름을 가지는 평행세계에 포함되는 백업지점입니다.  
모든 백업지점은 '특정 평행세계'에 포함되어야하고, 그 기본이 되는 평행세계가 'master'인 것이죠.  
  
예를 들어봅시다. 'master'라는 평행세계에서 A, B, C라는 백업지점을 만들었습니다. 그리고 B로 시간여행하여, 새로운 평행세계 structure를 만들어 D라는 백업지점을 만들었습니다.  
그럴 경우 'master'의 가장 최근은 C이고, 'structure'의 가장 최근은 D입니다.  
  
**시간여행(checkout)은 백업지점 혹은 평행세계 사이를 이동하는 동작**입니다.  
다만, 주의해야할 점이 하나 있습니다.  
평행세계의 이름을 사용하여 시간여행을 하면 특정 평행세계의 가장 최근 백업지점으로 이동됩니다.  
그러면 이번에는 시간여행을 통해 특정 백업지점으로 이동해보죠.  
위의 예시에서 A 백업지점으로 시간여행했다고 생각해보면, 당연히 현재 평행세계는 'master'라는 생각이 들겠지만 실제로는 그렇지 않습니다.  
모든 평행세계 자체도, 특정 시점으로부터 갈라져나왔을 뿐 과거가 없지는 않습니다. 그래서 'master'의 과거에도, 'structure'의 과거에도 A는 있습니다.  
따라서 A로 시간여행을 직접 수행하면 현재 자신이 어느 평행세계에 있는지 알 수 없습니다.  
사실 그냥 구경만 하러 왔다면 이게 크게 문제가 되지 않습니다. 하지만 여기서 무언가의 변경사항을 만들어 새로운 백업지점을 만드려고 한다면, 그때는 문제가 됩니다.  
백업지점은 항상 특정 평행세계에 포함되어있어야 하고, 더욱이 과거에 와서 역사를 바꾸는건 큰 문제가 있죠. 
그래서 과거에서 무언가를 바꾸려면 무조건 그 시점으로부터 평행세계를 다시 만들어야 합니다.  
그렇게 평행세계를 다시 만들면, 그 시점의 세상 하나가 또 만들어집니다. 그 이후로는 똑같이 백업지점을 만들거나 되돌릴 수도 있고, 그렇습니다.  

정리하자면 **백업지점을 만들고, 평행세계도 만들고, 특정 백업지점으로 시간여행을 해서 새로운 평행세계를 만들어 다시 새로운 백업지점을 만들 수도 있고, 아예 시간을 돌려 이후의 일을 모두 없던 일로 만들 수도 있습니다.**  
쉽게 말하자면 하나의 **타임머신+평행세계 생성기**인 것이죠.

### HEAD
**HEAD는 시계**입니다. 현재 속한 백업지점과 평행세계를 나타내는 시계에요.  
그런데 이 시계가 만약 특정 백업지점으로 시간여행되어있다면, 위에서도 언급했듯 어느 평행세계에 속해있는지는 알 수 없습니다.  
그래서 이 상황에서는 새로운 백업지점을 만들지는 못해요. 왜냐면 백업지점은 HEAD가 가리키는 평행세계의 가장 최근에 추가되어야 하니까요.  
그렇기에 이 상황에서 이미 존재하는 특정 평행세계로 이동하거나 새로운 평행세계를 만들어 HEAD에게 '나는 지금 여기에 있어'를 알려줘야합니다.

### 평행세계 합치기
서로 다른 두 평행세계를 합칩니다. 그 방식은 아래와 같아요.  
모든 사항에 대해 두 평행세계가 갈라져나온 기점을 찾아 두 평행세계의 가장 마지막 백업지점, 그리고 기점이되는 백업지점을 비교합니다.
- 지형의 경우 기점과 비교해 둘 평행세계 중 하나만 변경되었다면 그것을 반영하고, 둘 다 변경되었다면 **병합모드**에 따라 하나를 선택하여 반영합니다.
- 엔티티의 경우 기점과 비교하여 **병합모드**에 따라 한 쪽에만 있는 엔티티라면 추가된 것인지 삭제된 것인지를 판단하여 결과에 반영하고, 두 평행세계 모두에 존재하는 엔티티라면 **병합모드**에 따라 하나를 선택하여 반영합니다.  
  주민의 경우, 서로 다른 두 평행세계의 다른 엔티티가 기점의 같은 작업블록을 잡고 있었을 경우 **병합모드**에 따라 한 주민은 직업을 잃게됩니다.
  
두 평행세계를 합치는 것은 꽤 위험한 작업일 수 있습니다. 그래서 합친 이후에 자동으로 백업지점을 만들며, 합치기 전으로 시간을 되돌려 합친 일을 없던일로 만들 수 있도록 설계되어있습니다.  
따라서 합친 결과가 이상하거나 마음에 안들면 시간을 돌려버리면 됩니다.  

### 백업지점 확인 인수
모든 커맨드를 사용하여 '시간여행'을 수행할 경우, 클라이언트가 읽는 맵이 변경됩니다.  
사실 시간여행이나 백업지점, 평행세계 등은 모두 플러그인 디렉터리에서 관리되는 데이터이지만, 만약 시간여행을 수행하면 시간여행으로 이동한 시점의 플러그인 디렉터리 내의 월드 데이터를 
실제 클라이언트 디렉터리에 반영합니다. 따라서, 모든 백업지점을 만들지 않은 변경사항은 클라이언트에 덮어씌워지는 순간 소실됩니다.  
그렇기 때문에, 의도적으로 변경사항을 버리려는 의도가 아니라면 시간여행을 시작하기 전 모든 변경사항에 대한 백업지점을 만들고 시간여행 커맨드 맨 뒤에 `true` 를 전달해주세요.  
이 인수는 '아 맞다 백업지점 만들어야지'를 생각나게 해줄 하나의 장치입니다.

## 생길법한 궁금증
### 용량 안터져요?
터집니다. 많이 터집니다... 월드 하나하나를 직접 복사하여 관리하는 것은 아니고 Git이라는 시스템을 통해 관리하여 백업지점 하나 당 실제 월드 용량의 n배가 되지는 않습니다만, 그래도 아무튼 터지긴 터집니다.  
오버월드 하나만 버전관리했을 때 백업지점 하나당 10메가 정도 차지합니다(월드에 저장되어있는 Anvil 파일의 수에 따라 더 늘어날 수도 있습니다).  
그래서, 용량이 충분하지 않은 환경일 경우 '이제 이전 기록은 필요 없겠다' 싶은 시점을 잘 찾아 `/pixel init true` 명령을 수행해 이전 기록을 삭제해야할 수 있습니다.

### 속도는 어때요?
백업지점 만들기, 시간여행, 평행세계 만들기 등 **병합**을 제외한 모든 과정은 월드 하나만 수행했을 때 5초 내외로 수행이 가능합니다.  
다만, **병합**의 경우 계산량이 많아 월드 하나를 병합하려면 평균적으로 40초 ~ 1분 정도가 소요됩니다. 이 시간은 변경사항의 양이나 백업지점의 양과는 무관하기 때문에 거의 일정하다고 봐도 됩니다.  
물론 서버의 성능에 따라서 달라질 수는 있겠죠?